<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Water Physics Simulation</title>
    <style>
        :root {
            /* Light theme variables */
            --primary-color: #3498db;
            --secondary-color: #2980b9;
            --background-color: #f8f9fa;
            --text-color: #2c3e50;
            --panel-color: #ffffff;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --header-height: 60px;
            --water-gradient-1: #66a5f5;
            --water-gradient-2: #4295eb;
            --water-blur-color: rgba(66, 149, 235, 0.2);
            --water-core-color: rgba(86, 169, 255, 0.7);
            --water-surface-color: rgba(200, 230, 255, 0.9);
            --water-bg-color: #e3f2fd;
            --header-gradient-1: #3498db;
            --header-gradient-2: #2980b9;
            --preset-btn-bg: #f1f1f1;
            --preset-btn-text: #2c3e50;
            --preset-btn-hover: #e0e0e0;
            --info-panel-bg: rgba(255, 255, 255, 0.8);
            --border-color: #ddd;
        }
        
        [data-theme="dark"] {
            /* Dark theme variables */
            --primary-color: #2196f3;
            --secondary-color: #1976d2;
            --background-color: #121212;
            --text-color: #e0e0e0;
            --panel-color: #1e1e1e;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            --water-gradient-1: #4fc3f7;
            --water-gradient-2: #29b6f6;
            --water-blur-color: rgba(79, 195, 247, 0.25);
            --water-core-color: rgba(77, 208, 255, 0.8);
            --water-surface-color: rgba(100, 220, 255, 0.95);
            --water-bg-color: #0a1929;
            --header-gradient-1: #2196f3;
            --header-gradient-2: #1976d2;
            --preset-btn-bg: #333333;
            --preset-btn-text: #e0e0e0;
            --preset-btn-hover: #444444;
            --info-panel-bg: rgba(30, 30, 30, 0.8);
            --border-color: #444;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
        }
        
        body {
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
        }
        
        header {
            background: linear-gradient(135deg, var(--header-gradient-1), var(--header-gradient-2));
            color: white;
            padding: 0.5rem 1.5rem;
            box-shadow: var(--shadow);
            z-index: 10;
            height: var(--header-height);
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .title {
            font-size: 1.3rem;
            font-weight: 600;
        }
        
        .theme-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        main {
            display: flex;
            flex: 1;
            height: calc(100vh - var(--header-height));
            overflow: hidden;
            position: relative;
        }
        
        #simulation-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: var(--water-bg-color);
        }
        
        .control-panel {
            width: 280px;
            min-width: 200px;
            max-width: 350px;
            background-color: var(--panel-color);
            box-shadow: var(--shadow);
            padding: 0.8rem;
            overflow-y: auto;
            z-index: 5;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            flex: 0 0 auto;
            height: 100%;
        }
        
        .panel-section {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.8rem;
        }
        
        .panel-section:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        
        h2 {
            font-size: 1.1rem;
            margin-bottom: 0.7rem;
            color: var(--primary-color);
        }
        
        .control-group {
            margin-bottom: 0.7rem;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        label {
            display: block;
            margin-bottom: 0.2rem;
            font-size: 0.85rem;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 4px;
            background-color: var(--border-color);
        }
        
        input[type="number"] {
            width: 55px;
            padding: 0.2rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.85rem;
            background-color: var(--panel-color);
            color: var(--text-color);
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.5rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
            font-size: 0.9rem;
        }
        
        button:hover {
            background-color: var(--secondary-color);
        }
        
        .actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .preset-btn {
            background-color: var(--preset-btn-bg);
            color: var(--preset-btn-text);
            font-size: 0.8rem;
            padding: 0.3rem 0.7rem;
        }
        
        .preset-btn:hover {
            background-color: var(--preset-btn-hover);
        }
        
        .info-panel {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background-color: var(--info-panel-bg);
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.75rem;
            box-shadow: var(--shadow);
        }

        select {
            width: 100%;
            padding: 0.4rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--panel-color);
            color: var(--text-color);
        }

        .performance-indicator {
            margin-top: 0.5rem;
            height: 4px;
            width: 100%;
            background-color: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
        }

        .performance-bar {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.5s;
        }
        
        /* Media queries for responsive design */
        @media (max-width: 768px) {
            main {
                flex-direction: column;
                height: calc(100vh - var(--header-height));
            }
            
            .control-panel {
                width: 100%;
                max-width: none;
                height: auto;
                max-height: 40vh;
            }
            
            #simulation-container {
                height: 60vh;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="title">Realistic Water Physics Simulation</div>
        <button class="theme-toggle">Toggle Theme</button>
    </header>
    
    <main>
        <div id="simulation-container">
            <canvas id="simulation-canvas"></canvas>
            <div class="info-panel">
                <span id="particles-count">Particles: 0</span> |
                <span id="fps">FPS: 0</span> |
                <span id="optimization-level">Optimization: Auto</span>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="panel-section">
                <h2>Simulation Controls</h2>
                <div class="control-group">
                    <button id="start-pause">Pause</button>
                    <button id="reset">Reset</button>
                </div>
                <div class="control-group">
                    <label for="particles">Number of Particles:</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="range" id="particles" min="100" max="2000" value="1000" step="100">
                        <input type="number" id="particles-value" value="1000" min="100" max="2000" step="100">
                    </div>
                </div>
                <div class="control-group">
                    <label for="optimization">Performance Mode:</label>
                    <select id="optimization">
                        <option value="auto">Auto-Optimize</option>
                        <option value="high">Maximum Quality</option>
                        <option value="balanced">Balanced</option>
                        <option value="performance">Performance</option>
                    </select>
                    <div class="performance-indicator">
                        <div id="performance-bar" class="performance-bar"></div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <h2>Physics Parameters</h2>
                <div class="control-group">
                    <label for="gravity">Gravity:</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="range" id="gravity" min="0" max="20" value="9.8" step="0.1">
                        <input type="number" id="gravity-value" value="9.8" min="0" max="20" step="0.1">
                    </div>
                </div>
                <div class="control-group">
                    <label for="viscosity">Viscosity:</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="range" id="viscosity" min="0" max="1" value="0.12" step="0.01">
                        <input type="number" id="viscosity-value" value="0.12" min="0" max="1" step="0.01">
                    </div>
                </div>
                <div class="control-group">
                    <label for="tension">Surface Tension:</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="range" id="tension" min="0" max="1" value="0.35" step="0.01">
                        <input type="number" id="tension-value" value="0.35" min="0" max="1" step="0.01">
                    </div>
                </div>
                <div class="control-group">
                    <label for="stiffness">Pressure Stiffness:</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="range" id="stiffness" min="0" max="30" value="28" step="0.1">
                        <input type="number" id="stiffness-value" value="28" min="0" max="30" step="0.1">
                    </div>
                </div>
                <div class="control-group">
                    <label for="damping">Damping:</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="range" id="damping" min="0" max="0.5" value="0.03" step="0.01">
                        <input type="number" id="damping-value" value="0.03" min="0" max="0.5" step="0.01">
                    </div>
                </div>
                <div class="control-group">
                    <label for="repulsion">Repulsion Strength:</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="range" id="repulsion" min="0" max="100" value="45" step="1">
                        <input type="number" id="repulsion-value" value="45" min="0" max="100" step="1">
                    </div>
                </div>
                <div class="control-group">
                    <label for="cohesion">Cohesion Strength:</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="range" id="cohesion" min="0" max="50" value="10" step="1">
                        <input type="number" id="cohesion-value" value="10" min="0" max="50" step="1">
                    </div>
                </div>
                <div class="control-group">
                    <label for="leveling">Leveling Force:</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="range" id="leveling" min="0" max="0.5" value="0.2" step="0.01">
                        <input type="number" id="leveling-value" value="0.2" min="0" max="0.5" step="0.01">
                    </div>
                </div>
                <div class="control-group">
                    <label for="speed">Simulation Speed:</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="range" id="speed" min="0.1" max="2" value="1.0" step="0.1">
                        <input type="number" id="speed-value" value="1.0" min="0.1" max="2" step="0.1">
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <h2>Environment</h2>
                <div class="control-group">
                    <label for="obstacles">Obstacles:</label>
                    <select id="obstacles">
                        <option value="none">None</option>
                        <option value="circle">Circle</option>
                        <option value="rectangle">Rectangle</option>
                        <option value="custom">Custom Shape</option>
                    </select>
                </div>
                <div class="control-group">
                    <button id="add-water">Add Water</button>
                </div>
            </div>
            
            <div class="panel-section">
                <h2>Presets</h2>
                <div class="control-group">
                    <div class="actions">
                        <button class="preset-btn" data-preset="water">Default Water</button>
                        <button class="preset-btn" data-preset="honey">Honey</button>
                        <button class="preset-btn" data-preset="oil">Oil</button>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <script>
        // Constants for the simulation
        const PARTICLE_RADIUS = 5;
        const SMOOTHING_LENGTH = 25; 
        const REST_DENSITY = 40;
        const BOUNDARY_DAMPING = -0.5;
        const GRAVITY = 9.8;
        const MIN_PARTICLE_DISTANCE = PARTICLE_RADIUS * 0.7;
        const HYDROSTATIC_FACTOR = 1.5; // Increased from 1.0 for faster water leveling
        const SURFACE_THRESHOLD = 5;
        const GRAVITY_DOMINANCE = 1.5; // Increased from 1.0 for faster movement
        const MAX_LEVELING_DISTANCE = SMOOTHING_LENGTH * 0.9;
        const FIXED_TIMESTEP = 1/60; // Changed from 1/90 for better performance
        const MAX_DELTA_TIME = 0.05;
        const VISCOSITY_SCALE = 0.2; // Doubled for more responsive movement
        const SIMULATION_SPEED = 1.5; // Base speed increased
        const LEVELING_STRENGTH = 1.0; // Increased from 0.7
        const PRESSURE_EXPONENT = 2.0; // Reduced from 2.5 for faster stabilization
        
        // New optimization constants
        const PARTICLE_CULLING_MARGIN = 50;
        const SPATIAL_GRID_CELL_SIZE_FACTOR = 1.0;
        const DYNAMIC_SMOOTHING_LENGTH = true;
        const ADAPTIVE_PHYSICS_ENABLED = true;
        const PARTICLE_MERGE_DISTANCE = PARTICLE_RADIUS * 4;
        const PARTICLE_SPLIT_THRESHOLD = 5;
        const LOD_DISTANCE_THRESHOLD = 200;
        const MAX_PARTICLES_PER_FRAME = 1000;
        const OFFSCREEN_SIMPLIFICATION = true;
        const LOW_PERFORMANCE_THRESHOLD = 30;
        const DORMANT_VELOCITY_THRESHOLD = 0.5;
        const MAX_ACTIVE_PARTICLES_RATIO = 0.7;
        const AUTO_ADJUST_QUALITY = true; // New flag to enable auto quality adjustment
        const PERFORMANCE_CHECK_INTERVAL = 500; // Check performance more frequently (ms)

        // Modify optimization constants
        const SPATIAL_GRID_SIZE = SMOOTHING_LENGTH; // Use smoothing length as grid size
        const ACTIVE_RANGE = SMOOTHING_LENGTH * 4; // Only process particles within this range of active areas
        const MERGE_THRESHOLD = 0.8; // Merge particles when velocity difference is below this
        const SPLIT_THRESHOLD = 3.0; // Split merged particles above this velocity
        const MAX_PARTICLES_PER_CELL = 12; // Limit particles per spatial grid cell
        const CULLING_MARGIN = 100; // Pixels beyond viewport to simulate
        const BATCH_SIZE = 250; // Process physics in batches

        // Add worker pool size based on CPU cores
        const WORKER_COUNT = Math.max(2, navigator.hardwareConcurrency || 4);

        // Main simulation class with optimizations
        class WaterSimulation {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.particles = [];
                this.activeParticles = [];
                this.dormantParticles = [];
                this.mergedParticles = [];
                this.clusters = [];
                this.obstacles = [];
                this.paused = false;
                this.fps = 0;
                this.frameCount = 0;
                this.frameTime = 0;
                this.spatialHash = {};
                this.cellSize = SMOOTHING_LENGTH;
                this.waterLevel = 0;
                this.waterSurfaceParticles = [];
                this.lastOptimizationTime = 0;
                this.performanceHistory = [];
                this.dynamicTimeStep = FIXED_TIMESTEP;
                this.viewportMargin = PARTICLE_CULLING_MARGIN;
                this.isLowPerformanceMode = false;
                this.optimizationMode = "auto";
                this.particleActivityMap = new Map(); // Track particle activity
                this.framesSinceLastOptimization = 0;
                this.visibleRect = {
                    left: 0, 
                    top: 0, 
                    right: 0, 
                    bottom: 0
                };
                
                // Timing variables
                this.timeAccumulator = 0;
                this.previousPhysicsTime = 0;
                this.previousWallTime = 0;
                this.physicsTicks = 0;
                this.physicsHz = 0;
                this.physicsHzTime = 0;
                
                // Store previous and current states for interpolation
                this.particleStates = {
                    previous: [],
                    current: []
                };
                
                this.simulationQuality = {
                    particleDetail: 1.0,    // Level of detail for particles (1.0 = full)
                    physicsAccuracy: 1.0,   // Physics accuracy (1.0 = full)
                    renderQuality: 1.0,     // Render quality (1.0 = full)
                    maxActiveParticles: 1.0 // Ratio of particles that can be active
                };
                
                // Add optimization state tracking
                this.lastPerformanceCheck = 0;
                this.performanceCheckInterval = 1000; // Check performance every 1 second
                
                // Improved parameters for faster leveling
                this.params = {
                    gravity: 9.8,
                    viscosity: 0.12,
                    surfaceTension: 0.35,
                    pressureStiffness: 28,
                    repulsionStrength: 45,
                    cohesionStrength: 10,
                    damping: 0.03,
                    levelingForce: 0.2,
                    particleCount: 1000,
                    simulationSpeed: SIMULATION_SPEED
                };
                
                // Optimization: Add pre-allocated arrays for better performance
                this.cellVerified = {};
                this.neighborCache = {};
                this.neighborCacheFrame = 0;
                this.performanceMode = true;
                
                // Initialize WebGL if supported (for faster rendering)
                this.initWebGL();
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                this.reset();
                
                // Add device performance detection
                this.devicePerformanceRating = this.detectDevicePerformance();
                console.log(`Device performance rating: ${this.devicePerformanceRating}`);
                
                // Initialize state arrays
                this.initializeStates();

                // Initialize optimization history
                this.initOptimizationTracking();
                
                // Initialize Web Workers if supported
                this.initWebWorkers();
                
                // Initialize GPU compute if supported
                this.initGPUCompute();
                
                // Apply initial device-specific adjustments
                this.applyDeviceSpecificSettings();

                // Add spatial grid
                this.spatialGrid = new Map();
                this.activeCells = new Set();
                
                // Add worker pool
                this.workers = [];
                this.initializeWorkers();
            }
            
            // Detect device performance capabilities
            detectDevicePerformance() {
                let performanceScore = 1.0; // Default medium performance
                
                // Check processor cores
                const cores = navigator.hardwareConcurrency || 2;
                if (cores >= 8) performanceScore += 0.5;
                else if (cores <= 2) performanceScore -= 0.3;
                
                // Check if device is mobile
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) performanceScore -= 0.5;
                
                // Check GPU/WebGL capabilities
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (!gl) {
                        performanceScore -= 0.3;
                    } else {
                        // Check WebGL capabilities
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            if (renderer) {
                                if (/(nvidia|rtx|gtx)/i.test(renderer)) performanceScore += 0.4;
                                else if (/(intel)/i.test(renderer)) performanceScore += 0.1;
                                else if (/(adreno|mali|apple)/i.test(renderer)) performanceScore -= 0.2;
                            }
                        }
                    }
                } catch (e) {
                    console.warn("Error detecting GPU capabilities", e);
                    performanceScore -= 0.2;
                }
                
                // Clamp score between 0.5 and 2.0
                return Math.max(0.5, Math.min(2.0, performanceScore));
            }
            
            // Apply device-specific adjustments based on performance rating
            applyDeviceSpecificSettings() {
                // Adjust simulation speed based on performance rating
                const baseSpeed = this.params.simulationSpeed;
                const adjustedSpeed = baseSpeed * (1.2 / this.devicePerformanceRating);
                this.params.simulationSpeed = Math.min(adjustedSpeed, 2.0); // Cap at 2x
                
                console.log(`Applied device-specific speed adjustment: ${this.params.simulationSpeed}x`);
                
                // Update UI control
                const speedControl = document.getElementById('speed-value');
                if (speedControl) {
                    speedControl.value = this.params.simulationSpeed.toFixed(1);
                    document.getElementById('speed').value = this.params.simulationSpeed;
                }
                
                // Set initial optimization level based on device performance
                if (this.devicePerformanceRating < 0.8) {
                    // Low-end device: use performance mode
                    this.setOptimizationMode("performance");
                } else if (this.devicePerformanceRating > 1.5) {
                    // High-end device: use quality mode
                    this.setOptimizationMode("high");
                } else {
                    // Mid-range device: use balanced mode
                    this.setOptimizationMode("balanced");
                }
            }
            
            // Initialize Web Workers for parallel processing
            initWebWorkers() {
                this.useWorkers = window.Worker !== undefined;
                this.workers = [];
                this.workerCount = Math.max(2, navigator.hardwareConcurrency || 4);
                this.workerCount = Math.min(this.workerCount, 8); // Cap at 8 workers
                this.workerTasks = [];
                this.workerResults = [];
                this.workerBusy = false;
                this.workerEnabled = true; // Flag to actually use workers
                
                if (this.useWorkers) {
                    try {
                        // Create worker blob for inline definition
                        const workerScript = `
                            // Physics worker
                            self.onmessage = function(e) {
                                const { taskType, taskData, taskId } = e.data;
                                
                                if (taskType === 'computeDensityPressure') {
                                    const result = computeDensityPressure(taskData);
                                    self.postMessage({taskId, result});
                                } else if (taskType === 'computeForces') {
                                    const result = computeForces(taskData);
                                    self.postMessage({taskId, result});
                                } else if (taskType === 'integrate') {
                                    const result = integrate(taskData);
                                    self.postMessage({taskId, result});
                                }
                            };
                            
                            // SPH kernel functions
                            function kernel(r, h) {
                                if (r > h) return 0;
                                
                                const q = r / h;
                                const s = 8 / (Math.PI * Math.pow(h, 3));
                                
                                if (q <= 1) {
                                    return s * (1 - 1.5 * q * q + 0.75 * q * q * q);
                                } else {
                                    return s * 0.25 * Math.pow(2 - q, 3);
                                }
                            }
                            
                            function gradKernel(r, h, dx, dy) {
                                if (r > h || r === 0) return { x: 0, y: 0 };
                                
                                const q = r / h;
                                const s = 8 / (Math.PI * Math.pow(h, 4));
                                let factor;
                                
                                if (q <= 1) {
                                    factor = s * (-3 * q + 2.25 * q * q) / r;
                                } else {
                                    factor = s * -0.75 * Math.pow(2 - q, 2) / r;
                                }
                                
                                return {
                                    x: factor * dx,
                                    y: factor * dy
                                };
                            }
                            
                            // Process a chunk of particles for density & pressure
                            function computeDensityPressure(data) {
                                const { particles, spatialHash, cellSize, smoothingLength, restDensity, pressureStiffness, pressureExp } = data;
                                const results = [];
                                
                                for (const particleIndex of data.indices) {
                                    const particle = particles[particleIndex];
                                    let density = 0;
                                    let neighbors = 0;
                                    let nearSurface = false;
                                    
                                    // Self-density
                                    density += kernel(0, smoothingLength);
                                    
                                    // Get neighbors using spatial hash
                                    const cellX = Math.floor(particle.x / cellSize);
                                    const cellY = Math.floor(particle.y / cellSize);
                                    
                                    for (let i = -1; i <= 1; i++) {
                                        for (let j = -1; j <= 1; j++) {
                                            const cellKey = \`\${cellX + i},\${cellY + j}\`;
                                            const cellParticles = spatialHash[cellKey];
                                            
                                            if (cellParticles) {
                                                for (const idx of cellParticles) {
                                                    if (idx !== particleIndex) {
                                                        const p2 = particles[idx];
                                                        const dx = p2.x - particle.x;
                                                        const dy = p2.y - particle.y;
                                                        const r2 = dx * dx + dy * dy;
                                                        
                                                        if (r2 < smoothingLength * smoothingLength) {
                                                            const r = Math.sqrt(r2);
                                                            density += kernel(r, smoothingLength);
                                                            neighbors++;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Identify particles near surface
                                    if (neighbors < data.surfaceThreshold) {
                                        nearSurface = true;
                                    }
                                    
                                    // Calculate pressure
                                    const pressure = pressureStiffness * 
                                        Math.max(0, Math.pow(density / restDensity, pressureExp) - 1);
                                        
                                    results.push({
                                        index: particleIndex,
                                        density,
                                        pressure,
                                        neighbors,
                                        nearSurface
                                    });
                                }
                                
                                return results;
                            }
                            
                            // Process a chunk of particles for force calculation
                            function computeForces(data) {
                                const { particles, spatialHash, cellSize, smoothingLength, particleRadius, params, waterLevel } = data;
                                const results = [];
                                
                                for (const particleIndex of data.indices) {
                                    const particle = particles[particleIndex];
                                    let fx = 0;
                                    let fy = params.gravity;
                                    
                                    // Get neighbors using spatial hash
                                    const cellX = Math.floor(particle.x / cellSize);
                                    const cellY = Math.floor(particle.y / cellSize);
                                    const neighbors = [];
                                    
                                    for (let i = -1; i <= 1; i++) {
                                        for (let j = -1; j <= 1; j++) {
                                            const cellKey = \`\${cellX + i},\${cellY + j}\`;
                                            const cellParticles = spatialHash[cellKey];
                                            
                                            if (cellParticles) {
                                                for (const idx of cellParticles) {
                                                    if (idx !== particleIndex) {
                                                        const p2 = particles[idx];
                                                        const dx = p2.x - particle.x;
                                                        const dy = p2.y - particle.y;
                                                        const r2 = dx * dx + dy * dy;
                                                        
                                                        if (r2 < smoothingLength * smoothingLength) {
                                                            const r = Math.sqrt(r2);
                                                            neighbors.push({
                                                                particle: p2,
                                                                index: idx,
                                                                dx: dx,
                                                                dy: dy,
                                                                r: r
                                                            });
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Apply standard forces only if we have neighbors
                                    if (neighbors.length > 0) {
                                        // Process forces - only the important calculations, simplified for worker
                                        
                                        // Surface tension
                                        if (particle.nearSurface) {
                                            let colorGradX = 0;
                                            let colorGradY = 0;
                                            let colorLaplacian = 0;
                                            
                                            for (const n of neighbors) {
                                                if (n.r > 0) {
                                                    const kernelGrad = gradKernel(n.r, smoothingLength, n.dx, n.dy);
                                                    colorGradX += kernelGrad.x;
                                                    colorGradY += kernelGrad.y;
                                                    colorLaplacian += 2 * kernel(n.r, smoothingLength) / n.r;
                                                }
                                            }
                                            
                                            const colorGradMagnitude = Math.sqrt(colorGradX * colorGradX + colorGradY * colorGradY);
                                            
                                            if (colorGradMagnitude > 0.01) {
                                                const nx = colorGradX / (colorGradMagnitude || 1);
                                                const ny = colorGradY / (colorGradMagnitude || 1);
                                                
                                                const surfaceTensionForce = -params.surfaceTension * colorLaplacian;
                                                
                                                fx += surfaceTensionForce * nx;
                                                fy += surfaceTensionForce * ny;
                                            }
                                        }
                                        
                                        // Apply hydrostatic force
                                        const depthFromSurface = particle.y - waterLevel;
                                        if (Math.abs(depthFromSurface) > particleRadius * 0.5) {
                                            if (depthFromSurface > 0) {
                                                const hydroFactor = Math.min(depthFromSurface, params.gravity * 1.2);
                                                fy -= hydroFactor;
                                            } else if (depthFromSurface < 0) {
                                                const hydroFactor = Math.min(Math.abs(depthFromSurface), params.gravity * 0.8);
                                                fy += hydroFactor;
                                            }
                                        }
                                        
                                        // Pressure and viscosity forces
                                        for (const n of neighbors) {
                                            const neighbor = n.particle;
                                            const r = n.r;
                                            const dx = n.dx;
                                            const dy = n.dy;
                                            
                                            if (r > 0) {
                                                const nx = -dx / r;
                                                const ny = -dy / r;
                                                
                                                // Repulsion
                                                if (r < particleRadius * 2) {
                                                    const repulsionFactor = params.repulsionStrength * 
                                                        Math.pow(1.0 - r / (particleRadius * 2), 1.6);
                                                    
                                                    fx += repulsionFactor * nx;
                                                    fy += repulsionFactor * ny;
                                                }
                                                
                                                // Pressure
                                                if (particle.density > 0 && neighbor.density > 0) {
                                                    const pressureGrad = gradKernel(r, smoothingLength, dx, dy);
                                                    const pressureTerm = (particle.pressure / (particle.density * particle.density) + 
                                                        neighbor.pressure / (neighbor.density * neighbor.density));
                                                    
                                                    fx -= pressureTerm * pressureGrad.x;
                                                    fy -= pressureTerm * pressureGrad.y;
                                                }
                                                
                                                // Viscosity
                                                const dvx = neighbor.vx - particle.vx;
                                                const dvy = neighbor.vy - particle.vy;
                                                
                                                const viscosityFactor = params.viscosity * 0.1 * 
                                                    (1 - r / smoothingLength);
                                                
                                                fx += viscosityFactor * dvx;
                                                fy += viscosityFactor * dvy;
                                            }
                                        }
                                    }
                                    
                                    results.push({
                                        index: particleIndex,
                                        fx: fx,
                                        fy: fy
                                    });
                                }
                                
                                return results;
                            }
                            
                            function integrate(data) {
                                const { particles, boundaries, dt, dampingFactor } = data;
                                const results = [];
                                
                                for (const particleIndex of data.indices) {
                                    const p = particles[particleIndex];
                                    
                                    // Apply forces
                                    let vx = p.vx + p.fx * dt;
                                    let vy = p.vy + p.fy * dt;
                                    
                                    // Apply damping
                                    vx *= (1 - dampingFactor * dt);
                                    vy *= (1 - dampingFactor * dt);
                                    
                                    // Extra damping for extreme motion
                                    if (vy < -5) {
                                        vy *= (1 - 0.03 * dt);
                                    }
                                    
                                    // Update position
                                    let x = p.x + vx * dt;
                                    let y = p.y + vy * dt;
                                    
                                    // Handle boundaries
                                    const restitution = 0.5;
                                    
                                    // Left boundary
                                    if (x < boundaries.left) {
                                        vx = Math.abs(vx) * restitution;
                                        x = boundaries.left;
                                    }
                                    
                                    // Right boundary
                                    if (x > boundaries.right) {
                                        vx = -Math.abs(vx) * restitution;
                                        x = boundaries.right;
                                    }
                                    
                                    // Top boundary
                                    if (y < boundaries.top) {
                                        vy = Math.abs(vy) * restitution;
                                        y = boundaries.top;
                                    }
                                    
                                    // Bottom boundary
                                    if (y > boundaries.bottom) {
                                        vy = -Math.abs(vy) * restitution;
                                        y = boundaries.bottom;
                                        
                                        // Add random velocity on bottom collision
                                        vx += (Math.random() - 0.5) * 1.0;
                                    }
                                    
                                    results.push({
                                        index: particleIndex,
                                        x: x,
                                        y: y,
                                        vx: vx,
                                        vy: vy
                                    });
                                }
                                
                                return results;
                            }
                        `;
                        
                        const blob = new Blob([workerScript], {type: 'application/javascript'});
                        const workerURL = URL.createObjectURL(blob);
                        
                        // Create specified number of workers
                        for (let i = 0; i < this.workerCount; i++) {
                            this.workers.push(new Worker(workerURL));
                            
                            // Setup message handler for this worker
                            this.workers[i].onmessage = (e) => {
                                this.handleWorkerMessage(e.data);
                            };
                        }
                        
                        console.log(`Initialized ${this.workerCount} Web Workers for physics calculations`);
                    } catch (e) {
                        console.error("Failed to initialize Web Workers:", e);
                        this.useWorkers = false;
                    }
                }
            }
            
            // Initialize GPU computing using GPU.js if available
            initGPUCompute() {
                this.useGPU = false;
                
                // Check if GPU.js might be available (we'll load it dynamically)
                if (typeof WebGLRenderingContext !== 'undefined') {
                    this.loadGPUjs().then(gpuAvailable => {
                        if (gpuAvailable) {
                            try {
                                // Create GPU instance
                                this.gpu = new GPU.GPU();
                                
                                // Create density kernel
                                this.densityKernel = this.gpu.createKernel(function(positions, particleCount, smoothingLength) {
                                    const i = this.thread.x;
                                    let density = 0;
                                    
                                    // Self-density
                                    const selfKernel = 8.0 / (Math.PI * Math.pow(smoothingLength, 3));
                                    density += selfKernel;
                                    
                                    // Neighbor contributions (brute force approach for simplicity)
                                    const px = positions[i*2];
                                    const py = positions[i*2+1];
                                    
                                    for (let j = 0; j < particleCount; j++) {
                                        if (j !== i) {
                                            const nx = positions[j*2];
                                            const ny = positions[j*2+1];
                                            
                                            const dx = nx - px;
                                            const dy = ny - py;
                                            const r2 = dx*dx + dy*dy;
                                            
                                            if (r2 < smoothingLength*smoothingLength) {
                                                const r = Math.sqrt(r2);
                                                const q = r / smoothingLength;
                                                
                                                if (q <= 1) {
                                                    density += selfKernel * (1 - 1.5*q*q + 0.75*q*q*q);
                                                } else if (q <= 2) {
                                                    density += selfKernel * 0.25 * Math.pow(2-q, 3);
                                                }
                                            }
                                        }
                                    }
                                    
                                    return density;
                                })
                                .setOutput([2048]) // Max particles we'll compute in one batch
                                .setLoopMaxIterations(4000); // Increased loop limit
                                
                                this.useGPU = true;
                                console.log("GPU computing initialized successfully");
                            } catch (e) {
                                console.error("GPU computing initialization failed:", e);
                                this.useGPU = false;
                            }
                        }
                    });
                }
            }
            
            // Dynamically load GPU.js
            async loadGPUjs() {
                if (typeof GPU !== 'undefined') {
                    return true;
                }
                
                try {
                    // Create script element to load GPU.js from CDN
                    return new Promise((resolve) => {
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/npm/gpu.js@latest/dist/gpu-browser.min.js';
                        script.onload = () => resolve(true);
                        script.onerror = () => resolve(false);
                        document.head.appendChild(script);
                    });
                } catch (e) {
                    console.error("Failed to load GPU.js:", e);
                    return false;
                }
            }
            
            // Handle worker messages
            handleWorkerMessage(data) {
                const { taskId, result } = data;
                
                // Find the corresponding task
                const taskIndex = this.workerTasks.findIndex(task => task.id === taskId);
                
                if (taskIndex !== -1) {
                    const task = this.workerTasks[taskIndex];
                    
                    // Add result to results list
                    this.workerResults.push({
                        taskType: task.type,
                        result: result
                    });
                    
                    // Remove task from pending list
                    this.workerTasks.splice(taskIndex, 1);
                    
                    // If all tasks are complete, finalize the results
                    if (this.workerTasks.length === 0 && this.workerResults.length > 0) {
                        this.finalizeWorkerResults();
                    }
                }
            }
            
            // Apply all the results received from workers
            finalizeWorkerResults() {
                for (const resultItem of this.workerResults) {
                    if (resultItem.taskType === 'computeDensityPressure') {
                        // Apply density and pressure results
                        for (const particleResult of resultItem.result) {
                            const particle = this.particles[particleResult.index];
                            particle.density = particleResult.density;
                            particle.pressure = particleResult.pressure;
                            particle.neighbors = particleResult.neighbors;
                            particle.nearSurface = particleResult.nearSurface;
                        }
                    } else if (resultItem.taskType === 'computeForces') {
                        // Apply force results
                        for (const particleResult of resultItem.result) {
                            const particle = this.particles[particleResult.index];
                            particle.fx = particleResult.fx;
                            particle.fy = particleResult.fy;
                        }
                    } else if (resultItem.taskType === 'integrate') {
                        // Apply integration results
                        for (const particleResult of resultItem.result) {
                            const particle = this.particles[particleResult.index];
                            particle.x = particleResult.x;
                            particle.y = particleResult.y;
                            particle.vx = particleResult.vx;
                            particle.vy = particleResult.vy;
                        }
                    }
                }
                
                // Clear results list
                this.workerResults = [];
                this.workerBusy = false;
                
                // Signal that worker processing is complete
                this.workerProcessingComplete();
            }
            
            // Add the missing workerProcessingComplete method
            workerProcessingComplete() {
                // All worker tasks are complete, continue with the next physics step
                this.workerBusy = false;
                
                // If we're in a sequence of steps, continue with the next one
                if (this.pendingPhysicsSteps && this.pendingPhysicsSteps > 0) {
                    this.pendingPhysicsSteps--;
                    this.processPhysicsStep();
                }
            }
            
            // Initialize WebGL renderer if supported
            initWebGL() {
                try {
                    // Try to get WebGL context
                    this.glCtx = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                    
                    if (this.glCtx) {
                        this.hasWebGL = true;
                        this.initShaders();
                        console.log("WebGL rendering enabled");
                    } else {
                        this.hasWebGL = false;
                        console.log("WebGL not supported, using Canvas 2D");
                    }
                } catch (e) {
                    this.hasWebGL = false;
                    console.error("WebGL initialization failed:", e);
                }
            }
            
            // Initialize WebGL shaders
            initShaders() {
                if (!this.hasWebGL) return;
                
                // Vertex shader program
                const vsSource = `
                    attribute vec2 aVertexPosition;
                    attribute float aPointSize;
                    attribute vec4 aColor;
                    
                    uniform mat4 uModelViewMatrix;
                    uniform mat4 uProjectionMatrix;
                    
                    varying vec4 vColor;
                    
                    void main() {
                        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 0.0, 1.0);
                        gl_PointSize = aPointSize;
                        vColor = aColor;
                    }
                `;
                
                // Fragment shader program
                const fsSource = `
                    precision mediump float;
                    varying vec4 vColor;
                    
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5, 0.5)) * 2.0;
                        float alpha = 1.0 - smoothstep(0.8, 1.0, dist);
                        gl_FragColor = vec4(vColor.rgb, vColor.a * alpha);
                    }
                `;
                
                // Create shader program
                this.shaderProgram = this.createShaderProgram(vsSource, fsSource);
                
                if (this.shaderProgram) {
                    // Get attribute and uniform locations
                    this.programInfo = {
                        program: this.shaderProgram,
                        attribLocations: {
                            vertexPosition: this.glCtx.getAttribLocation(this.shaderProgram, 'aVertexPosition'),
                            pointSize: this.glCtx.getAttribLocation(this.shaderProgram, 'aPointSize'),
                            color: this.glCtx.getAttribLocation(this.shaderProgram, 'aColor'),
                        },
                        uniformLocations: {
                            projectionMatrix: this.glCtx.getUniformLocation(this.shaderProgram, 'uProjectionMatrix'),
                            modelViewMatrix: this.glCtx.getUniformLocation(this.shaderProgram, 'uModelViewMatrix'),
                        },
                    };
                    
                    // Initialize buffers
                    this.initBuffers();
                }
            }
            
            // Create a shader program
            createShaderProgram(vsSource, fsSource) {
                const gl = this.glCtx;
                
                const vertexShader = this.loadShader(gl.VERTEX_SHADER, vsSource);
                const fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fsSource);
                
                if (!vertexShader || !fragmentShader) return null;
                
                // Create the shader program
                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);
                
                // Check if program linked successfully
                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                    return null;
                }
                
                return shaderProgram;
            }
            
            // Load a shader
            loadShader(type, source) {
                const gl = this.glCtx;
                const shader = gl.createShader(type);
                
                // Send the source to the shader object
                gl.shaderSource(shader, source);
                
                // Compile the shader program
                gl.compileShader(shader);
                
                // Check if it compiled successfully
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            // Initialize WebGL buffers
            initBuffers() {
                const gl = this.glCtx;
                
                // Create buffers for particle positions, sizes and colors
                this.buffers = {
                    position: gl.createBuffer(),
                    size: gl.createBuffer(),
                    color: gl.createBuffer(),
                };
            }
            
            // Initialize optimization tracking
            initOptimizationTracking() {
                this.performanceHistory = new Array(10).fill(60); // Start with 60fps history
                this.adaptiveSettings = {
                    currentLevel: 0,
                    levels: [
                        // Level 0: Maximum quality
                        {
                            particleDetail: 1.0,
                            physicsAccuracy: 1.0,
                            renderQuality: 1.0,
                            maxActiveParticles: 1.0
                        },
                        // Level 1: High quality
                        {
                            particleDetail: 0.9,
                            physicsAccuracy: 0.9,
                            renderQuality: 0.9,
                            maxActiveParticles: 0.95
                        },
                        // Level 2: Medium quality
                        {
                            particleDetail: 0.7,
                            physicsAccuracy: 0.8,
                            renderQuality: 0.7,
                            maxActiveParticles: 0.85
                        },
                        // Level 3: Low quality
                        {
                            particleDetail: 0.5,
                            physicsAccuracy: 0.7,
                            renderQuality: 0.6,
                            maxActiveParticles: 0.7
                        },
                        // Level 4: Minimum quality
                        {
                            particleDetail: 0.4,
                            physicsAccuracy: 0.6,
                            renderQuality: 0.4,
                            maxActiveParticles: 0.6
                        },
                    ]
                };
            }
            
            // Apply optimization level based on performance
            applyOptimizationLevel(level) {
                if (level >= 0 && level < this.adaptiveSettings.levels.length) {
                    this.simulationQuality = { ...this.adaptiveSettings.levels[level] };
                    this.adaptiveSettings.currentLevel = level;
                    
                    // Update UI
                    const levelNames = ["Maximum", "High", "Balanced", "Low", "Minimum"];
                    const levelName = levelNames[level] || "Custom";
                    document.getElementById('optimization-level').textContent = `Optimization: ${levelName}`;
                    
                    // Update performance bar
                    const perfBar = document.getElementById('performance-bar');
                    if (perfBar) {
                        perfBar.style.width = `${(1 - level / (this.adaptiveSettings.levels.length - 1)) * 100}%`;
                    }
                    
                    console.log(`Applied optimization level ${level}: ${levelName}`);
                    return true;
                }
                return false;
            }
            
            // Auto-optimize based on performance
            checkAndOptimize() {
                const now = performance.now();
                if (now - this.lastPerformanceCheck < PERFORMANCE_CHECK_INTERVAL) {
                    return;
                }
                
                this.lastPerformanceCheck = now;
                
                // Only auto-optimize if in auto mode
                if (this.optimizationMode !== "auto" || !AUTO_ADJUST_QUALITY) {
                    return;
                }
                
                // Calculate average fps
                const avgFps = this.performanceHistory.reduce((a, b) => a + b, 0) / this.performanceHistory.length;
                
                // Adjust optimization level based on performance thresholds
                if (avgFps < 20) {
                    // Very poor performance - apply maximum optimization
                    if (this.adaptiveSettings.currentLevel < this.adaptiveSettings.levels.length - 1) {
                        this.applyOptimizationLevel(this.adaptiveSettings.levels.length - 1);
                        console.log(`Auto-optimizing: Performance critical (${avgFps.toFixed(1)} FPS) -> Maximum optimization`);
                        
                        // Toggle WebGL and Workers based on performance
                        if (this.particles.length > 500) {
                            this.workerEnabled = true; // Enable workers for many particles
                        } else {
                            this.workerEnabled = false; // Disable workers for few particles (overhead)
                        }
                    }
                } else if (avgFps < 30) {
                    // Poor performance - increase optimization
                    if (this.adaptiveSettings.currentLevel < this.adaptiveSettings.levels.length - 2) {
                        this.applyOptimizationLevel(this.adaptiveSettings.currentLevel + 1);
                        console.log(`Auto-optimizing: Performance low (${avgFps.toFixed(1)} FPS) -> Increasing optimization`);
                    }
                } else if (avgFps > 55 && this.particles.length > 300) {
                    // Good performance - consider decreasing optimization
                    if (this.adaptiveSettings.currentLevel > 0) {
                        this.applyOptimizationLevel(this.adaptiveSettings.currentLevel - 1);
                        console.log(`Auto-optimizing: Performance good (${avgFps.toFixed(1)} FPS) -> Decreasing optimization`);
                    }
                }
                
                // Update performance bar
                const perfBar = document.getElementById('performance-bar');
                if (perfBar) {
                    perfBar.style.width = `${Math.min(100, Math.max(0, avgFps / 60 * 100))}%`;
                }
            }
            
            // Update the simulation's optimization mode
            setOptimizationMode(mode) {
                this.optimizationMode = mode;
                
                // Apply appropriate optimization level based on mode
                switch (mode) {
                    case "high":
                        this.applyOptimizationLevel(0); // Maximum quality
                        break;
                    case "balanced":
                        this.applyOptimizationLevel(2); // Medium quality
                        break;
                    case "performance":
                        this.applyOptimizationLevel(4); // Minimum quality
                        break;
                    case "auto":
                    default:
                        // Start with balanced and let auto-optimizer adjust
                        this.applyOptimizationLevel(2);
                        break;
                }
                
                console.log(`Set optimization mode to: ${mode}`);
            }
            
            // Initialize state arrays for interpolation
            initializeStates() {
                this.particleStates.previous = [];
                this.particleStates.current = [];
                
                // Copy particle states
                for (const particle of this.particles) {
                    this.particleStates.previous.push({
                        x: particle.x,
                        y: particle.y
                    });
                    
                    this.particleStates.current.push({
                        x: particle.x,
                        y: particle.y
                    });
                }
            }
            
            // Store current states as previous before physics update
            updateStates() {
                // Ensure arrays are the right size
                while (this.particleStates.previous.length < this.particles.length) {
                    this.particleStates.previous.push({x: 0, y: 0});
                    this.particleStates.current.push({x: 0, y: 0});
                }
                
                // Copy current to previous
                for (let i = 0; i < this.particles.length; i++) {
                    this.particleStates.previous[i].x = this.particleStates.current[i].x;
                    this.particleStates.previous[i].y = this.particleStates.current[i].y;
                    
                    // Update current state
                    this.particleStates.current[i].x = this.particles[i].x;
                    this.particleStates.current[i].y = this.particles[i].y;
                }
            }
            
            resize() {
                this.canvas.width = this.canvas.parentElement.clientWidth;
                this.canvas.height = this.canvas.parentElement.clientHeight;
                this.width = this.canvas.width;
                this.height = this.canvas.height;
            }
            
            reset() {
                this.particles = [];
                this.createParticles(this.params.particleCount);
                document.getElementById('particles-count').textContent = `Particles: ${this.particles.length}`;
                
                // Reset timing variables
                this.timeAccumulator = 0;
                this.previousPhysicsTime = 0;
                this.previousWallTime = 0;
                
                // Initialize states
                this.initializeStates();
            }
            
            createParticles(count) {
                const containerWidth = this.width * 0.3;
                const containerHeight = this.height * 0.4;
                const startX = (this.width - containerWidth) / 2;
                const startY = 50;
                
                for (let i = 0; i < count; i++) {
                    const x = startX + Math.random() * containerWidth;
                    const y = startY + Math.random() * containerHeight;
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: 0,
                        vy: 0,
                        fx: 0,
                        fy: 0,
                        density: 0,
                        pressure: 0
                    });
                }
            }
            
            addWater(amount = 100) {
                const startX = Math.random() * (this.width - 100) + 50;
                const startY = 20;
                
                for (let i = 0; i < amount; i++) {
                    const x = startX + Math.random() * 50;
                    const y = startY + Math.random() * 20;
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: 0,
                        vy: 0,
                        fx: 0,
                        fy: 0,
                        density: 0,
                        pressure: 0
                    });
                }
                
                document.getElementById('particles-count').textContent = `Particles: ${this.particles.length}`;
            }
            
            // Faster spatial hash building with direct array indexing
            buildSpatialHash() {
                // Reset spatial hash
                this.spatialHash = {};
                this.cellVerified = {};
                
                // Build spatial hash with array pre-allocation
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    const cellX = Math.floor(p.x / this.cellSize);
                    const cellY = Math.floor(p.y / this.cellSize);
                    const cellKey = `${cellX},${cellY}`;
                    
                    if (!this.cellVerified[cellKey]) {
                        this.spatialHash[cellKey] = [];
                        this.cellVerified[cellKey] = true;
                    }
                    
                    this.spatialHash[cellKey].push(i);
                }
                
                // Increment neighbor cache frame to invalidate cache
                this.neighborCacheFrame++;
                
                // Clear neighbor cache if it's too large (memory optimization)
                if (Object.keys(this.neighborCache).length > 10000) {
                    this.neighborCache = {};
                }
            }
            
            // Optimized neighbor finding with caching
            getNeighbors(particle, particleIndex) {
                // Try to use cached neighbors if available from this frame
                const cacheKey = `${particleIndex}_${this.neighborCacheFrame}`;
                if (this.neighborCache[cacheKey]) {
                    return this.neighborCache[cacheKey];
                }
                
                const neighbors = [];
                const cellX = Math.floor(particle.x / this.cellSize);
                const cellY = Math.floor(particle.y / this.cellSize);
                
                // Check surrounding cells
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const cellKey = `${cellX + i},${cellY + j}`;
                        const cellParticles = this.spatialHash[cellKey];
                        
                        if (cellParticles) {
                            for (const idx of cellParticles) {
                                const p = this.particles[idx];
                                if (idx !== particleIndex) {
                                    const dx = p.x - particle.x;
                                    const dy = p.y - particle.y;
                                    const r2 = dx * dx + dy * dy;
                                    
                                    // Optimization: Use squared distance check
                                    if (r2 < SMOOTHING_LENGTH * SMOOTHING_LENGTH) {
                                        const r = Math.sqrt(r2); // Only calculate sqrt when needed
                                        neighbors.push({
                                            particle: p,
                                            dx: dx,
                                            dy: dy,
                                            r: r
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Cache the results
                this.neighborCache[cacheKey] = neighbors;
                
                return neighbors;
            }
            
            // Kernel function for SPH - using cubic spline kernel for better stability
            kernel(r, h) {
                if (r > h) return 0;
                
                const q = r / h;
                const s = 8 / (Math.PI * Math.pow(h, 3));
                
                if (q <= 1) {
                    return s * (1 - 1.5 * q * q + 0.75 * q * q * q);
                } else {
                    return s * 0.25 * Math.pow(2 - q, 3);
                }
            }
            
            gradKernel(r, h, dx, dy) {
                if (r > h || r === 0) return { x: 0, y: 0 };
                
                const q = r / h;
                const s = 8 / (Math.PI * Math.pow(h, 4));
                let factor;
                
                if (q <= 1) {
                    factor = s * (-3 * q + 2.25 * q * q) / r;
                } else {
                    factor = s * -0.75 * Math.pow(2 - q, 2) / r;
                }
                
                return {
                    x: factor * dx,
                    y: factor * dy
                };
            }
            
            // Calculate color field for surface tension (more accurate model)
            calculateColorField(particle, neighbors) {
                // Color gradient calculation (magnitude and direction)
                let colorGradX = 0;
                let colorGradY = 0;
                let colorLaplacian = 0;
                
                for (const n of neighbors) {
                    if (n.r > 0) {
                        // Unit direction from particle to neighbor
                        const nx = n.dx / n.r;
                        const ny = n.dy / n.r;
                        
                        // Contribution to color gradient
                        const kernelGrad = this.gradKernel(n.r, SMOOTHING_LENGTH, n.dx, n.dy);
                        colorGradX += kernelGrad.x;
                        colorGradY += kernelGrad.y;
                        
                        // Contribution to color laplacian (for curvature)
                        colorLaplacian += 2 * this.kernel(n.r, SMOOTHING_LENGTH) / n.r;
                    }
                }
                
                // Normalize color gradient
                const colorGradMagnitude = Math.sqrt(colorGradX * colorGradX + colorGradY * colorGradY);
                
                return {
                    gradientX: colorGradX,
                    gradientY: colorGradY,
                    magnitude: colorGradMagnitude,
                    laplacian: colorLaplacian
                };
            }
            
            // More efficient water level calculation using sampling
            calculateWaterLevel() {
                if (this.particles.length === 0) return 0;
                
                // First do a quick rough pass to find approximate water top surface
                // Sample only a subset of particles for better performance
                const sampleCount = Math.min(this.particles.length, 200);
                const sampleStep = Math.max(1, Math.floor(this.particles.length / sampleCount));
                const sampledParticles = [];
                
                for (let i = 0; i < this.particles.length; i += sampleStep) {
                    sampledParticles.push(this.particles[i]);
                }
                
                // Sort by y-coordinate
                sampledParticles.sort((a, b) => a.y - b.y);
                
                // Take approximately top 20% of particles
                const topCount = Math.max(5, Math.floor(sampledParticles.length * 0.2));
                const topParticles = sampledParticles.slice(0, topCount);
                
                // Calculate top height as a baseline
                let roughTopLevel = 0;
                for (const p of topParticles) {
                    roughTopLevel += p.y;
                }
                roughTopLevel /= topCount;
                
                // Now find real surface particles
                this.waterSurfaceParticles = [];
                
                // Use height threshold from the rough pass to find surface particles
                for (let i = 0; i < this.particles.length; i++) {
                    const particle = this.particles[i];
                    
                    // Only check particles near the rough top level
                    if (particle.y > roughTopLevel + SMOOTHING_LENGTH * 0.5) continue;
                    
                    let neighborsAbove = 0;
                    const neighbors = this.getNeighbors(particle, i);
                    
                    // Count particles above this one
                    for (const n of neighbors) {
                        if (n.dy < -PARTICLE_RADIUS) {
                            neighborsAbove++;
                        }
                    }
                    
                    // If few neighbors above and enough total neighbors, it's a surface particle
                    if (neighborsAbove <= 2 && neighbors.length >= 2) {
                        this.waterSurfaceParticles.push(particle);
                        particle.isSurface = true;
                    } else {
                        particle.isSurface = false;
                    }
                }
                
                // If we found surface particles, use them
                if (this.waterSurfaceParticles.length > 0) {
                    // Get median water level for better stability
                    const heights = this.waterSurfaceParticles.map(p => p.y).sort((a, b) => a - b);
                    const medianIndex = Math.floor(heights.length / 2);
                    return heights[medianIndex];
                }
                
                // Fallback to rough estimate
                return roughTopLevel;
            }
            
            computeDensityPressure() {
                // Build spatial hash for neighbor finding
                this.buildSpatialHash();
                
                // Compute density and pressure for all particles
                for (let i = 0; i < this.particles.length; i++) {
                    const particle = this.particles[i];
                    
                    // Reset properties
                    particle.density = 0;
                    particle.nearSurface = false;
                    particle.neighbors = 0;
                    particle.isSurface = false;
                    
                    // Self-density
                    particle.density += this.kernel(0, SMOOTHING_LENGTH);
                    
                    // Contribution from neighbors
                    const neighbors = this.getNeighbors(particle, i);
                    particle.neighbors = neighbors.length;
                    
                    for (const n of neighbors) {
                        particle.density += this.kernel(n.r, SMOOTHING_LENGTH);
                    }
                    
                    // Identify particles near surface
                    if (neighbors.length < SURFACE_THRESHOLD) {
                        particle.nearSurface = true;
                    }
                    
                    // Much stronger pressure response for better level surfaces
                    particle.pressure = this.params.pressureStiffness * 
                                      Math.max(0, Math.pow(particle.density / REST_DENSITY, PRESSURE_EXPONENT) - 1);
                }
                
                // Calculate the average water level
                this.waterLevel = this.calculateWaterLevel();
                
                // Store the water level in particles for consistent force application
                for (let i = 0; i < this.particles.length; i++) {
                    this.particles[i].waterLevel = this.waterLevel;
                }
            }
            
            // Main physics step - fixed timestep
            step(dt) {
                // Scale dt by simulation speed
                const scaledDt = dt * this.params.simulationSpeed;
                
                if (this.useWorkers && this.workerEnabled && !this.workerBusy) {
                    // Use web workers for physics
                    this.pendingPhysicsSteps = 1;
                    this.processPhysicsStep();
                } else {
                    // Use regular physics processing
                    this.computeDensityPressure();
                    this.computeForces();
                }
                
                // Always integrate locally (not using workers for this)
                this.integrate(scaledDt);
            }
            
            // Modified to actually use Web Workers for physics
            processPhysicsStep() {
                if (!this.useWorkers || !this.workerEnabled || this.workerBusy) {
                    // Fall back to regular processing if workers aren't available
                    this.computeDensityPressure();
                    this.computeForces();
                    return;
                }
                
                this.workerBusy = true;
                
                // Build spatial hash for use by workers
                this.buildSpatialHash();
                
                // Prepare particle data
                const particleData = this.particles.map(p => ({
                    x: p.x, y: p.y, vx: p.vx, vy: p.vy,
                    density: p.density, pressure: p.pressure,
                    nearSurface: p.nearSurface
                }));
                
                // Split particles into chunks for workers
                const chunkSize = Math.ceil(this.particles.length / this.workerCount);
                const taskId = Date.now().toString() + Math.random().toString().slice(2);
                
                for (let i = 0; i < this.workerCount; i++) {
                    const startIdx = i * chunkSize;
                    const endIdx = Math.min(startIdx + chunkSize, this.particles.length);
                    
                    if (startIdx >= this.particles.length) break;
                    
                    const indices = Array.from({length: endIdx - startIdx}, (_, j) => startIdx + j);
                    
                    // Create and queue the worker task
                    const taskData = {
                        taskId: taskId + '_' + i,
                        taskType: 'computeDensityPressure',
                        taskData: {
                            particles: particleData,
                            indices: indices,
                            spatialHash: this.spatialHash,
                            cellSize: this.cellSize,
                            smoothingLength: SMOOTHING_LENGTH,
                            restDensity: REST_DENSITY,
                            pressureStiffness: this.params.pressureStiffness,
                            pressureExp: PRESSURE_EXPONENT,
                            surfaceThreshold: SURFACE_THRESHOLD
                        }
                    };
                    
                    this.workerTasks.push({
                        id: taskData.taskId,
                        type: taskData.taskType
                    });
                    
                    this.workers[i].postMessage(taskData);
                }
            }
            
            computeForces() {
                // Optimization: Pre-filter active particles 
                // (those with neighbors - isolated particles can be skipped)
                this.activeParticles = [];
                for (let i = 0; i < this.particles.length; i++) {
                    const particle = this.particles[i];
                    
                    // Reset forces first
                    particle.fx = 0;
                    particle.fy = this.params.gravity * GRAVITY_DOMINANCE;
                    
                    // Track particles with neighbors that need force calculation
                    const neighbors = this.getNeighbors(particle, i);
                    if (neighbors.length > 0 || particle.nearSurface) {
                        this.activeParticles.push({particle, index: i});
                    }
                }
                
                // Calculate forces only for active particles
                for (const {particle, index} of this.activeParticles) {
                    const neighbors = this.getNeighbors(particle, index);
                    const isInWater = particle.density > (REST_DENSITY * 0.3);
                    
                    // Standard forces: surface tension, repulsion, pressure, viscosity
                    if (particle.isSurface || particle.nearSurface) {
                        const colorField = this.calculateColorField(particle, neighbors);
                        
                        if (colorField.magnitude > 0.01) {
                            const nx = colorField.gradientX / (colorField.magnitude || 1);
                            const ny = colorField.gradientY / (colorField.magnitude || 1);
                            
                            const surfaceTensionCoeff = this.params.surfaceTension;
                            const surfaceTensionForce = -surfaceTensionCoeff * colorField.laplacian;
                            
                            particle.fx += surfaceTensionForce * nx;
                            particle.fy += surfaceTensionForce * ny;
                        }
                    }
                    
                    // Enhanced hydrostatic force for faster leveling
                    // This is the key to creating level water surfaces
                    const depthFromSurface = particle.y - particle.waterLevel;
                    
                    if (isInWater) {
                        // Apply much stronger, faster-acting hydrostatic forces
                        if (Math.abs(depthFromSurface) > PARTICLE_RADIUS * 0.5) {
                            // Below water level: apply upward hydrostatic force - INCREASED STRENGTH
                            if (depthFromSurface > 0) {
                                const hydroFactor = Math.min(
                                    depthFromSurface * HYDROSTATIC_FACTOR * 1.5, // Increased by 50%
                                    this.params.gravity * 1.8  // Can exceed gravity by more for faster leveling
                                );
                                
                                // Apply stronger exponential force for faster convergence near surface
                                particle.fy -= hydroFactor * (1.0 + 0.4 * Math.sqrt(particle.density / REST_DENSITY));
                            }
                            // Above water level: apply stronger downward force
                            else if (depthFromSurface < 0) {
                                const hydroFactor = Math.min(
                                    Math.abs(depthFromSurface) * HYDROSTATIC_FACTOR * 1.2, // Increased by 30%
                                    this.params.gravity * 1.2  // Allow stronger downward force
                                );
                                
                                // Apply stronger downward force
                                particle.fy += hydroFactor * 1.25;
                            }
                        }
                    }
                    
                    // Direct water height leveling forces - ENHANCED IMPLEMENTATION
                    if (neighbors.length > 0) {
                        // Compute average height of neighbors with improved weighting
                        let localAvgHeight = 0;
                        let weightSum = 0;
                        
                        // Find particles especially in horizontal neighborhood with stronger influence
                        for (const n of neighbors) {
                            // Prioritize horizontal neighbors even more for better leveling
                            const horizontalness = Math.abs(n.dx) / (Math.abs(n.dy) + 0.01);
                            const weight = Math.max(0, 1 - n.r / MAX_LEVELING_DISTANCE) * 
                                         (1 + horizontalness * 0.8); // Increased horizontal influence
                            
                            localAvgHeight += n.particle.y * weight;
                            weightSum += weight;
                        }
                        
                        if (weightSum > 0) {
                            localAvgHeight /= weightSum;
                            const heightDiff = particle.y - localAvgHeight;
                            
                            // Apply a much stronger leveling force based on local height difference
                            if (Math.abs(heightDiff) > PARTICLE_RADIUS * 0.2) { // Reduced threshold
                                // Scale leveling force by how close to surface
                                const surfaceProximity = particle.isSurface ? 1.5 : // Increased surface influence
                                                      (particle.nearSurface ? 1.2 : 0.9);
                                
                                // Leveling force is proportional to height difference
                                // and stronger closer to surface
                                const levelForce = heightDiff * this.params.levelingForce * 1.5 * surfaceProximity;
                                
                                // Add a stronger leveling force, less capped relative to gravity
                                const maxLevel = this.params.gravity * 1.2; // Increased cap
                                const minLevel = -this.params.gravity * 1.2;
                                particle.fy -= Math.max(Math.min(levelForce, maxLevel), minLevel);
                            }
                        }
                    }
                    
                    // Apply standard SPH pressure and viscosity forces
                    for (const n of neighbors) {
                        const neighbor = n.particle;
                        const r = n.r;
                        const dx = n.dx;
                        const dy = n.dy;
                        
                        if (r > 0) {
                            const nx = -dx / r;
                            const ny = -dy / r;
                            
                            // Short-range particle repulsion
                            if (r < PARTICLE_RADIUS * 2) {
                                const repulsionFactor = this.params.repulsionStrength * 
                                                     Math.pow(1.0 - r / (PARTICLE_RADIUS * 2), 1.6);
                                
                                particle.fx += repulsionFactor * nx;
                                particle.fy += repulsionFactor * ny;
                            }
                            
                            // Pressure force with aggressive response curve for better leveling
                            if (particle.density > 0 && neighbor.density > 0) {
                                const pressureGrad = this.gradKernel(r, SMOOTHING_LENGTH, dx, dy);
                                
                                // Symmetric pressure formulation, enhanced response
                                const pressureTerm = (particle.pressure / (particle.density * particle.density) + 
                                                 neighbor.pressure / (neighbor.density * neighbor.density));
                                
                                particle.fx -= pressureTerm * pressureGrad.x;
                                particle.fy -= pressureTerm * pressureGrad.y;
                            }
                            
                            // Optimized viscosity calculation
                            const dvx = neighbor.vx - particle.vx;
                            const dvy = neighbor.vy - particle.vy;
                            
                            const viscosityFactor = this.params.viscosity * VISCOSITY_SCALE * 
                                                 (1 - r / SMOOTHING_LENGTH);
                            
                            particle.fx += viscosityFactor * dvx;
                            particle.fy += viscosityFactor * dvy;
                            
                            // Directional cohesion (mostly horizontal)
                            const heightDiff = Math.abs(particle.y - neighbor.y);
                            
                            if (r > PARTICLE_RADIUS * 1.5 && heightDiff < SMOOTHING_LENGTH * 0.4) {
                                // More horizontal cohesion, less vertical
                                const horizontalFactor = Math.max(0, 1 - heightDiff / (SMOOTHING_LENGTH * 0.4));
                                const cohesionFactor = this.params.cohesionStrength * 
                                                    (1.0 - r / SMOOTHING_LENGTH) * 
                                                    horizontalFactor;
                                
                                // Lateral cohesion helps create smoother surfaces
                                particle.fx -= cohesionFactor * nx;
                                
                                // Minimal vertical cohesion
                                const verticalFactor = 0.02;
                                particle.fy -= cohesionFactor * ny * verticalFactor;
                            }
                        }
                    }
                    
                    // Extra downward bias for non-surface particles
                    if (!particle.isSurface) {
                        particle.fy += 0.03; // Slight extra gravity for faster settling
                    }
                }
                
                // Limit maximum forces
                const maxForce = 550; // Slightly higher to allow stronger leveling
                for (const {particle} of this.activeParticles) {
                    const fx = particle.fx;
                    const fy = particle.fy;
                    const forceMagnitude = Math.sqrt(fx * fx + fy * fy);
                    
                    if (forceMagnitude > maxForce) {
                        const scaleFactor = maxForce / forceMagnitude;
                        particle.fx *= scaleFactor;
                        particle.fy *= scaleFactor;
                    }
                }
            }
            
            integrate(dt) {
                // Store current particle positions for interpolation
                this.updateStates();
                
                // Update velocities and positions
                for (const particle of this.particles) {
                    // Apply forces
                    particle.vx += particle.fx * dt;
                    particle.vy += particle.fy * dt;
                    
                    // Apply consistent damping not tied to viscosity
                    const dampingFactor = this.params.damping;
                    
                    particle.vx *= (1 - dampingFactor * dt);
                    particle.vy *= (1 - dampingFactor * dt);
                    
                    // Extra damping only for extreme upward motion
                    if (particle.vy < -5) { 
                        particle.vy *= (1 - 0.03 * dt);
                    }
                    
                    // Update position
                    particle.x += particle.vx * dt;
                    particle.y += particle.vy * dt;
                    
                    // Handle boundary conditions
                    this.enforceBoundary(particle);
                }
                
                // Resolve collisions
                this.resolveCollisions();
            }
            
            // Direct collision resolution between particles that may have interpenetrated
            resolveCollisions() {
                // Use spatial hash for efficient neighbor finding
                for (let i = 0; i < this.particles.length; i++) {
                    const p1 = this.particles[i];
                    const cellX = Math.floor(p1.x / this.cellSize);
                    const cellY = Math.floor(p1.y / this.cellSize);
                    
                    // Check surrounding cells for overlapping particles
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const cellKey = `${cellX + dx},${cellY + dy}`;
                            const cellParticles = this.spatialHash[cellKey];
                            
                            if (cellParticles) {
                                for (const idx of cellParticles) {
                                    if (idx > i) { // Only check each pair once
                                        const p2 = this.particles[idx];
                                        
                                        const dx = p2.x - p1.x;
                                        const dy = p2.y - p1.y;
                                        const distSq = dx * dx + dy * dy;
                                        const minDist = PARTICLE_RADIUS * 2;
                                        
                                        // If particles are overlapping
                                        if (distSq < minDist * minDist) {
                                            const dist = Math.sqrt(distSq);
                                            const overlap = minDist - dist;
                                            
                                            if (dist > 0) {
                                                // Push particles apart based on overlap
                                                const nx = dx / dist;
                                                const ny = dy / dist;
                                                
                                                // Each particle moves half the distance
                                                const moveX = nx * overlap * 0.5;
                                                const moveY = ny * overlap * 0.5;
                                                
                                                p1.x -= moveX;
                                                p1.y -= moveY;
                                                p2.x += moveX;
                                                p2.y += moveY;
                                                
                                                // Adjust velocities for realistic collision response
                                                const relVelX = p2.vx - p1.vx;
                                                const relVelY = p2.vy - p1.vy;
                                                
                                                const relVelDotNormal = relVelX * nx + relVelY * ny;
                                                
                                                // Only apply impulse if particles are moving toward each other
                                                if (relVelDotNormal < 0) {
                                                    const restitution = 0.3; // Coefficient of restitution
                                                    const impulse = (-(1 + restitution) * relVelDotNormal) / 2;
                                                    
                                                    p1.vx -= impulse * nx;
                                                    p1.vy -= impulse * ny;
                                                    p2.vx += impulse * nx;
                                                    p2.vy += impulse * ny;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            enforceBoundary(particle) {
                // More bouncy walls for more dynamic behavior
                const restitution = 0.5;
                
                // Left boundary
                if (particle.x < PARTICLE_RADIUS) {
                    particle.vx = Math.abs(particle.vx) * restitution;
                    particle.x = PARTICLE_RADIUS;
                }
                
                // Right boundary
                if (particle.x > this.width - PARTICLE_RADIUS) {
                    particle.vx = -Math.abs(particle.vx) * restitution;
                    particle.x = this.width - PARTICLE_RADIUS;
                }
                
                // Top boundary
                if (particle.y < PARTICLE_RADIUS) {
                    particle.vy = Math.abs(particle.vy) * restitution;
                    particle.y = PARTICLE_RADIUS;
                }
                
                // Bottom boundary
                if (particle.y > this.height - PARTICLE_RADIUS) {
                    particle.vy = -Math.abs(particle.vy) * restitution;
                    particle.y = this.height - PARTICLE_RADIUS;
                    
                    // Add random velocity on bottom collision for more natural flow
                    particle.vx += (Math.random() - 0.5) * 1.0;
                }
            }
            
            // Main update loop - called each animation frame
            update(timestamp) {
                // Convert timestamp to seconds
                const timeInSeconds = timestamp / 1000;
                
                // First frame - initialize timing
                if (this.previousWallTime === 0) {
                    this.previousWallTime = timeInSeconds;
                    this.previousPhysicsTime = timeInSeconds;
                    requestAnimationFrame(t => this.update(t));
                    return;
                }
                
                // Calculate the elapsed time since last frame
                const deltaTime = Math.min(timeInSeconds - this.previousWallTime, MAX_DELTA_TIME);
                this.previousWallTime = timeInSeconds;
                
                // Only accumulate time and run physics if not paused
                if (!this.paused) {
                    // Accumulate time for fixed-step physics
                    this.timeAccumulator += deltaTime;
                    
                    // Run physics simulation at fixed intervals
                    // This ensures consistent behavior regardless of frame rate
                    while (this.timeAccumulator >= FIXED_TIMESTEP) {
                        this.step(FIXED_TIMESTEP);
                        this.timeAccumulator -= FIXED_TIMESTEP;
                        this.physicsTicks++;
                    }
                    
                    // Track physics steps per second (for debug)
                    this.physicsHzTime += deltaTime;
                    if (this.physicsHzTime >= 1.0) {
                        this.physicsHz = this.physicsTicks;
                        this.physicsTicks = 0;
                        this.physicsHzTime -= 1.0;
                    }
                }
                
                // Calculate interpolation alpha for rendering
                // Alpha 0 = previous state, 1 = current state
                const alpha = this.timeAccumulator / FIXED_TIMESTEP;
                
                // Update FPS counter and performance tracking
                this.frameCount++;
                this.frameTime += deltaTime;
                if (this.frameTime >= 1.0) {
                    this.fps = this.frameCount;
                    // Update display with FPS and physics Hz for debugging
                    document.getElementById('fps').textContent = `FPS: ${this.fps} | Physics: ${this.physicsHz}Hz`;
                    
                    // Update performance history for optimization
                    this.performanceHistory.push(this.fps);
                    if (this.performanceHistory.length > 10) {
                        this.performanceHistory.shift(); // Keep only the last 10 measurements
                    }
                    
                    // Check and adjust optimization if needed
                    this.checkAndOptimize();
                    
                    this.frameCount = 0;
                    this.frameTime = 0;
                }
                
                // Render the scene with interpolation
                this.render(alpha);
                
                // Request next frame
                requestAnimationFrame(t => this.update(t));
            }
            
            // Optimized rendering that uses batch processing and fewer gradients
            render(interpolationAlpha) {
                if (this.hasWebGL && this.shaderProgram) {
                    this.renderWithWebGL(interpolationAlpha);
                } else {
                    this.renderWithCanvas2D(interpolationAlpha);
                }
            }
            
            // New WebGL rendering method that actually uses WebGL
            renderWithWebGL(interpolationAlpha) {
                const gl = this.glCtx;
                
                // Clear the canvas
                gl.clearColor(0.9, 0.95, 1.0, 0.2);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                // Don't try to render if we have no particles
                if (this.particles.length === 0) return;
                
                // Setup viewport and projection matrix
                gl.viewport(0, 0, this.width, this.height);
                
                // Create orthographic projection matrix
                const projectionMatrix = [
                    2 / this.width, 0, 0, 0,
                    0, -2 / this.height, 0, 0,
                    0, 0, 1, 0,
                    -1, 1, 0, 1
                ];
                
                // Simple model-view matrix (identity)
                const modelViewMatrix = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
                
                // Set the shader program and matrices
                gl.useProgram(this.shaderProgram);
                gl.uniformMatrix4fv(this.programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(this.programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
                
                // Create arrays for particle data
                const positions = new Float32Array(this.particles.length * 2);
                const sizes = new Float32Array(this.particles.length);
                const colors = new Float32Array(this.particles.length * 4);
                
                // Fill arrays with particle data
                for (let i = 0; i < this.particles.length; i++) {
                    const particle = this.particles[i];
                    
                    // Calculate interpolated position
                    let renderX = particle.x;
                    let renderY = particle.y;
                    
                    if (i < this.particleStates.previous.length && i < this.particleStates.current.length) {
                        const prevState = this.particleStates.previous[i];
                        const currState = this.particleStates.current[i];
                        
                        renderX = prevState.x + (currState.x - prevState.x) * interpolationAlpha;
                        renderY = prevState.y + (currState.y - prevState.y) * interpolationAlpha;
                    }
                    
                    positions[i * 2] = renderX;
                    positions[i * 2 + 1] = renderY;
                    
                    // Set size based on whether it's a surface particle
                    sizes[i] = particle.isSurface ? PARTICLE_RADIUS * 2.2 : PARTICLE_RADIUS * 2;
                    
                    // Set color based on depth
                    const depth = Math.max(0, Math.min(1, (renderY / this.height) * 2));
                    colors[i * 4] = (66 + depth * 20) / 255; // r
                    colors[i * 4 + 1] = (165 + depth * 30) / 255; // g
                    colors[i * 4 + 2] = (245 - depth * 50) / 255; // b
                    colors[i * 4 + 3] = particle.isSurface ? 0.95 : 0.8; // alpha
                }
                
                // Update buffer data
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
                gl.vertexAttribPointer(this.programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.size);
                gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.DYNAMIC_DRAW);
                gl.vertexAttribPointer(this.programInfo.attribLocations.pointSize, 1, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.programInfo.attribLocations.pointSize);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.color);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.DYNAMIC_DRAW);
                gl.vertexAttribPointer(this.programInfo.attribLocations.color, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.programInfo.attribLocations.color);
                
                // Enable blending for transparent particles
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                
                // Draw particles
                gl.drawArrays(gl.POINTS, 0, this.particles.length);
                
                // Disable attributes
                gl.disableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);
                gl.disableVertexAttribArray(this.programInfo.attribLocations.pointSize);
                gl.disableVertexAttribArray(this.programInfo.attribLocations.color);
            }
            
            // Existing Canvas2D rendering as fallback
            renderWithCanvas2D(interpolationAlpha) {
                // Clear canvas with a single call
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // Draw water background
                this.ctx.fillStyle = 'rgba(225, 242, 254, 0.2)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Draw surface water level indicator (for debugging)
                // this.ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
                // this.ctx.beginPath();
                // this.ctx.moveTo(0, this.waterLevel);
                // this.ctx.lineTo(this.width, this.waterLevel);
                // this.ctx.stroke();
                
                // Create batches of particles for more efficient rendering
                // Group by similar depth/color rather than drawing each particle individually
                const depthBatches = new Map();
                const batchSize = 0.1; // 10 depth batches
                
                // Group particles by depth for batch rendering
                for (let i = 0; i < this.particles.length; i++) {
                    const particle = this.particles[i];
                    
                    // Calculate interpolated position
                    let renderX = particle.x;
                    let renderY = particle.y;
                    
                    if (i < this.particleStates.previous.length && i < this.particleStates.current.length) {
                        const prevState = this.particleStates.previous[i];
                        const currState = this.particleStates.current[i];
                        
                        renderX = prevState.x + (currState.x - prevState.x) * interpolationAlpha;
                        renderY = prevState.y + (currState.y - prevState.y) * interpolationAlpha;
                    }
                    
                    // Determine depth batch
                    const depth = Math.max(0, Math.min(1, (renderY / this.height) * 2));
                    const batchKey = Math.floor(depth / batchSize) * batchSize;
                    
                    if (!depthBatches.has(batchKey)) {
                        depthBatches.set(batchKey, {
                            depth: depth,
                            particles: []
                        });
                    }
                    
                    // Add position to appropriate batch
                    const batch = depthBatches.get(batchKey);
                    batch.particles.push({
                        x: renderX,
                        y: renderY,
                        isSurface: particle.isSurface
                    });
                }
                
                // Render particles in batches by depth
                depthBatches.forEach((batch, batchKey) => {
                    const depth = batch.depth;
                    
                    // Calculate single color for this depth batch
                    const r = Math.floor(66 + depth * 20);
                    const g = Math.floor(165 + depth * 30);
                    const b = Math.floor(245 - depth * 50);
                    
                    // Draw blur circles first (use one gradient per batch)
                    const blurRadius = PARTICLE_RADIUS * 2.8;
                    this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.2)`;
                    
                    // Draw all particle blurs in this batch
                    for (const p of batch.particles) {
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, blurRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // Draw core circles next (same color but more opaque)
                    this.ctx.fillStyle = `rgba(${r + 20}, ${g + 20}, ${b}, 0.7)`;
                    
                    // Draw all particle cores in this batch
                    for (const p of batch.particles) {
                        // Use different radius for surface particles
                        const coreRadius = p.isSurface ? PARTICLE_RADIUS * 0.8 : PARTICLE_RADIUS * 0.7;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, coreRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
            }
            
            togglePause() {
                this.paused = !this.paused;
                return this.paused;
            }
            
            applyPreset(presetName) {
                switch(presetName) {
                    case 'water':
                        this.params = {
                            gravity: 9.8,
                            viscosity: 0.12,      // Fixed viscosity scaled value
                            surfaceTension: 0.35, 
                            pressureStiffness: 35,       // Higher for better level surfaces
                            repulsionStrength: 45,
                            cohesionStrength: 10,
                            damping: 0.03,
                            levelingForce: LEVELING_STRENGTH,
                            particleCount: this.params.particleCount,
                            simulationSpeed: SIMULATION_SPEED
                        };
                        break;
                    case 'honey':
                        this.params = {
                            gravity: 9.8,
                            viscosity: 0.9,       // Very high viscosity for honey
                            surfaceTension: 0.8,
                            pressureStiffness: 20,
                            repulsionStrength: 40,
                            cohesionStrength: 25,
                            damping: 0.4,
                            levelingForce: 0.08,
                            particleCount: this.params.particleCount,
                            simulationSpeed: SIMULATION_SPEED * 0.4 // Honey simulates at 40% speed
                        };
                        break;
                    case 'oil':
                        this.params = {
                            gravity: 9.8,
                            viscosity: 0.35,
                            surfaceTension: 0.25,
                            pressureStiffness: 18,
                            repulsionStrength: 35,
                            cohesionStrength: 7,
                            damping: 0.06,
                            levelingForce: 0.1,
                            particleCount: this.params.particleCount,
                            simulationSpeed: SIMULATION_SPEED * 0.7 // Oil simulates at 70% speed
                        };
                        break;
                }
                
                // Update UI to reflect new parameters
                updateControlsFromParams();
            }

            initializeWorkers() {
                if (typeof Worker !== 'undefined') {
                    for (let i = 0; i < WORKER_COUNT; i++) {
                        const worker = new Worker(URL.createObjectURL(new Blob([`
                            onmessage = function(e) {
                                const { particles, start, end, dt } = e.data;
                                const results = [];
                                
                                for (let i = start; i < end; i++) {
                                    const p = particles[i];
                                    // Physics calculations
                                    // ... (implement particle physics here)
                                    results.push({
                                        index: i,
                                        x: p.x + p.vx * dt,
                                        y: p.y + p.vy * dt,
                                        vx: p.vx,
                                        vy: p.vy
                                    });
                                }
                                
                                postMessage(results);
                            };
                        `])));
                        this.workers.push(worker);
                    }
                }
            }

            updateSpatialGrid() {
                this.spatialGrid.clear();
                this.activeCells.clear();
        
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    const cellX = Math.floor(p.x / SPATIAL_GRID_SIZE);
                    const cellY = Math.floor(p.y / SPATIAL_GRID_SIZE);
                    const key = `${cellX},${cellY}`;
                    
                    if (!this.spatialGrid.has(key)) {
                        this.spatialGrid.set(key, []);
                    }
                    
                    const cell = this.spatialGrid.get(key);
                    if (cell.length < MAX_PARTICLES_PER_CELL) {
                        cell.push(i);
                        
                        // Mark cells within active range
                        if (this.isParticleActive(p)) {
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    this.activeCells.add(`${cellX + dx},${cellY + dy}`);
                                }
                            }
                        }
                    }
                }
            }
        
            isParticleActive(particle) {
                // Check if particle is on screen or moving significantly
                const onScreen = particle.x >= -CULLING_MARGIN && 
                                particle.x <= this.width + CULLING_MARGIN &&
                                particle.y >= -CULLING_MARGIN && 
                                particle.y <= this.height + CULLING_MARGIN;
                                
                const moving = Math.abs(particle.vx) > 0.1 || Math.abs(particle.vy) > 0.1;
                return onScreen || moving;
            }
        
            processPhysicsInBatches() {
                const batchCount = Math.ceil(this.particles.length / BATCH_SIZE);
                let completed = 0;
        
                for (let i = 0; i < batchCount; i++) {
                    const start = i * BATCH_SIZE;
                    const end = Math.min(start + BATCH_SIZE, this.particles.length);
                    
                    if (this.workers.length > 0) {
                        // Use worker from pool
                        const worker = this.workers[i % this.workers.length];
                        worker.postMessage({
                            particles: this.particles.slice(start, end),
                            start,
                            end,
                            dt: this.timeStep
                        });
                        
                        worker.onmessage = (e) => {
                            this.updateParticlesBatch(e.data);
                            completed++;
                            if (completed === batchCount) {
                                this.finalizePhysicsUpdate();
                            }
                        };
                    } else {
                        // Fallback to synchronous processing
                        this.updateParticlesBatch(this.processParticleBatch(start, end));
                        completed++;
                    }
                }
            }

            // Override the existing particle merging logic
            handleParticleMerging() {
                // Only check cells with active particles
                for (const cellKey of this.activeCells) {
                    const particles = this.spatialGrid.get(cellKey) || [];
                    if (particles.length < 2) continue;
        
                    // Check for potential merges in this cell
                    for (let i = 0; i < particles.length; i++) {
                        const p1 = this.particles[particles[i]];
                        if (p1.merged) continue;
        
                        for (let j = i + 1; j < particles.length; j++) {
                            const p2 = this.particles[particles[j]];
                            if (p2.merged) continue;
        
                            const dx = p2.x - p1.x;
                            const dy = p2.y - p1.y;
                            const distSq = dx * dx + dy * dy;
        
                            if (distSq < PARTICLE_RADIUS * PARTICLE_RADIUS * 4) {
                                const velDiff = Math.abs(p1.vx - p2.vx) + Math.abs(p1.vy - p2.vy);
                                
                                if (velDiff < MERGE_THRESHOLD) {
                                    this.mergeParticles(p1, p2);
                                }
                            }
                        }
                    }
                }
            }
            
            // Add this new method
            mergeParticles(p1, p2) {
                // Average positions and velocities
                p1.x = (p1.x + p2.x) * 0.5;
                p1.y = (p1.y + p2.y) * 0.5;
                p1.vx = (p1.vx + p2.vx) * 0.5;
                p1.vy = (p1.vy + p2.vy) * 0.5;
                p1.mass = (p1.mass || 1) + (p2.mass || 1);
                
                // Mark second particle as merged
                p2.merged = true;
                p2.mergedInto = p1;
            }
        }
        
        // Initialize the simulation when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('simulation-canvas');
            const simulation = new WaterSimulation(canvas);
            
            // Handle window resize to keep canvas dimensions correct
            function handleResize() {
                // Force a resize of the canvas when window dimensions change
                simulation.resize();
                
                // Calculate correct dimensions for canvas based on container
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
            }
            
            // Set initial size
            handleResize();
            
            // Add resize event listener
            window.addEventListener('resize', handleResize);
            
            // Start the animation loop
            requestAnimationFrame(timestamp => simulation.update(timestamp));
            
            // Control event listeners
            document.getElementById('start-pause').addEventListener('click', (e) => {
                const isPaused = simulation.togglePause();
                e.target.textContent = isPaused ? 'Resume' : 'Pause';
            });
            
            document.getElementById('reset').addEventListener('click', () => {
                simulation.reset();
            });
            
            document.getElementById('add-water').addEventListener('click', () => {
                simulation.addWater(100);
            });
            
            // Optimization selector
            document.getElementById('optimization').addEventListener('change', (e) => {
                simulation.setOptimizationMode(e.target.value);
            });
            
            // Preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const preset = e.target.dataset.preset;
                    simulation.applyPreset(preset);
                });
            });
            
            // Sync sliders with number inputs
            function syncInputs(sliderId, valueId) {
                const slider = document.getElementById(sliderId);
                const value = document.getElementById(valueId);
                
                slider.addEventListener('input', () => {
                    value.value = slider.value;
                    updateSimulationParams();
                });
                
                value.addEventListener('input', () => {
                    slider.value = value.value;
                    updateSimulationParams();
                });
            }
            
            // Setup all control syncs
            syncInputs('particles', 'particles-value');
            syncInputs('gravity', 'gravity-value');
            syncInputs('viscosity', 'viscosity-value');
            syncInputs('tension', 'tension-value');
            syncInputs('stiffness', 'stiffness-value');
            syncInputs('damping', 'damping-value');
            syncInputs('repulsion', 'repulsion-value');
            syncInputs('cohesion', 'cohesion-value');
            syncInputs('leveling', 'leveling-value');
            syncInputs('speed', 'speed-value');
            
            // Update simulation parameters function
            function updateSimulationParams() {
                simulation.params.particleCount = parseInt(document.getElementById('particles-value').value);
                simulation.params.gravity = parseFloat(document.getElementById('gravity-value').value);
                simulation.params.viscosity = parseFloat(document.getElementById('viscosity-value').value);
                simulation.params.surfaceTension = parseFloat(document.getElementById('tension-value').value);
                simulation.params.pressureStiffness = parseFloat(document.getElementById('stiffness-value').value);
                simulation.params.damping = parseFloat(document.getElementById('damping-value').value);
                simulation.params.repulsionStrength = parseFloat(document.getElementById('repulsion-value').value);
                simulation.params.cohesionStrength = parseFloat(document.getElementById('cohesion-value').value);
                simulation.params.levelingForce = parseFloat(document.getElementById('leveling-value').value);
                simulation.params.simulationSpeed = parseFloat(document.getElementById('speed-value').value);
                
                // Apply device-specific adjustments when manual values are changed
                const newCount = parseInt(document.getElementById('particles-value').value);
                if (newCount !== simulation.params.particleCount) {
                    // Update worker optimization based on particle count
                    if (simulation.useWorkers) {
                        simulation.workerEnabled = newCount > 300; // Only use workers for larger particle counts
                    }
                }
            }
            
            // Update UI controls from simulation parameters
            function updateControlsFromParams() {
                document.getElementById('particles').value = simulation.params.particleCount;
                document.getElementById('particles-value').value = simulation.params.particleCount;
                
                document.getElementById('gravity').value = simulation.params.gravity;
                document.getElementById('gravity-value').value = simulation.params.gravity;
                
                document.getElementById('viscosity').value = simulation.params.viscosity;
                document.getElementById('viscosity-value').value = simulation.params.viscosity;
                
                document.getElementById('tension').value = simulation.params.surfaceTension;
                document.getElementById('tension-value').value = simulation.params.surfaceTension;
                
                document.getElementById('stiffness').value = simulation.params.pressureStiffness;
                document.getElementById('stiffness-value').value = simulation.params.pressureStiffness;
                
                document.getElementById('damping').value = simulation.params.damping;
                document.getElementById('damping-value').value = simulation.params.damping;
                
                document.getElementById('repulsion').value = simulation.params.repulsionStrength;
                document.getElementById('repulsion-value').value = simulation.params.repulsionStrength;
                
                document.getElementById('cohesion').value = simulation.params.cohesionStrength;
                document.getElementById('cohesion-value').value = simulation.params.cohesionStrength;
                
                document.getElementById('leveling').value = simulation.params.levelingForce;
                document.getElementById('leveling-value').value = simulation.params.levelingForce;
                
                document.getElementById('speed').value = simulation.params.simulationSpeed;
                document.getElementById('speed-value').value = simulation.params.simulationSpeed;
            }
            
            // Initialize parameters
            updateSimulationParams();
            
            // Apply initial optimization mode
            simulation.setOptimizationMode(document.getElementById('optimization').value);
        });
    </script>
</body>
</html>
